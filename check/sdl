#define DEBUG	0
if (sdl.init()) {
    print("init error: %s\n", sdl.get_error());
    exit(1);
}
sdl.window_t win = sdl.create_window("SDL example!",
				     sdl.WindowposCentered,
				     sdl.WindowposCentered,
				     640, 480,
				     sdl.WindowShown);
if (win == null) {
    print("create_window error: %s\n", sdl.get_error());
    exit(1);
}
#if DEBUG
print("\n\
window		%a\n\
x:		%d\n\
y:		%d\n\
w:		%d\n\
h:		%d\n\
min_w:		%d\n\
min_h:		%d\n\
max_w:		%d\n\
max_h:		%d\n\
flags:		%s%s%s%s%s%s%s%s%s%s%s%s%s\n\
title:		%#a\n\
brightness:	%d\n",
      win,
      win.x, win.y, win.w, win.h, win.min_w, win.min_h, win.max_w, win.max_h,
      win.flags & sdl.WindowFullscreenDesktop ?
      (win.flags & sdl.WindowFullscreenDesktop == sdl.WindowFullscreenDesktop ?
       "WindowFullscreenDesktop " : "WindowFullscreen ") : "",
      win.flags & sdl.WindowOpenGL ? "OpenGL " : "",
      win.flags & sdl.WindowShown ? "Shown " : "",
      win.flags & sdl.WindowHidden ? "Hidden " : "",
      win.flags & sdl.WindowBorderless ? "Borderless " : "",
      win.flags & sdl.WindowResizable ? "Resizable " : "",
      win.flags & sdl.WindowMinimized ? "Minimized " : "",
      win.flags & sdl.WindowMaximized ? "Maximized " : "",
      win.flags & sdl.WindowInputGrabbed ? "InputGrabbed " : "",
      win.flags & sdl.WindowInputFocus ? "InputFocus " : "",
      win.flags & sdl.WindowMouseFocus ? "MouseFocus " : "",
      win.flags & sdl.WindowForeign ? "Foreign " : "",
      win.flags & sdl.WindowAllowHighDpi ? "AllowHighDpi " : "",
      win.title, win.brightness);
#endif
sdl.renderer_t ren = sdl.create_renderer(win, -1,
					 sdl.RendererAccelerated |
					 sdl.RendererPresentVsync);
if (ren == null) {
    print("create_renderer error: %s\n", sdl.get_error());
    exit(1);
}
#if DEBUG
print("\n\
renderer	%a\n\
target:		%a\n\
log_w:		%d\n\
log_h:		%d\n\
max_w:		%d\n\
max_h:		%d\n\
name:		%#s\n\
flags:		%s%s%s%s\n\
formats:	",
      ren,
      ren.target, ren.log_w, ren.log_h, ren.max_w, ren.max_h, ren.name,
      ren.flags & sdl.RendererSoftware ? "Software " : "",
      ren.flags & sdl.RendererAccelerated ? "Accelerated " : "",
      ren.flags & sdl.RendererPresentVsync ? "PresentVsync " : "",
      ren.flags & sdl.RendererTargetTexture ? "TargetTexture " : "");
int32_t i;
for (i = 0; i < sizeof(ren.formats); ++i)
    print("%#x ", ren.formats[i]);
print("\n\
max_w:		%d\n\
max_h:		%d\n\
view_x:		%d\n\
view_y:		%d\n\
view_w:		%d\n\
view_h:		%d\n\
clip_x:		%d\n\
clip_y:		%d\n\
clip_w:		%d\n\
clip_h:		%d\n\
scale_x:	%d\n\
scale_y:	%d\n\
r:		%d\n\
g:		%d\n\
b:		%d\n\
a:		%d\n",
      ren.max_w, ren.max_h, ren.view_x, ren.view_y, ren.view_w, ren.view_h,
      ren.clip_x, ren.clip_y, ren.clip_w, ren.clip_h,
      ren.scale_x, ren.scale_y, ren.r, ren.g, ren.b, ren.a);
if (ren.blend)
    print("\
blend:		%s%s%s\n",
	  ren.blend & sdl.BlendModeBlend ? "Blend " : "",
	  ren.blend & sdl.BlendModeAdd ? "Add " : "",
	  ren.blend & sdl.BlendModeMod ? "Mod " : "");
else
    print("\
blend:		None\n");
print("\n\
get_window_renderer(win) = %a\n\
get_renderer_window(ren) = %a\n",
      sdl.get_window_renderer(win), sdl.get_renderer_window(ren));
#endif
sdl.texture_t bg = sdl.load_texture(ren, "check/0.png");
if (bg == null) {
    print("load_texture error: %s\n", sdl.get_error());
    exit(1);
}
#if DEBUG
print("\n\
texture\n\
format:		%#x\n\
access:		%s\n\
w:		%d\n\
h:		%d\n\
r:		%#x\n\
g:		%#x\n\
b:		%#x\n\
a:		%#x\n",
      bg.format,
      bg.access == sdl.TextureAccessStatic ? "Static" :
      bg.access == sdl.TextureAccessStreaming ? "Streaming" :
      bg.access == sdl.TextureAccessTarget ? "Target" : "???",
      bg.w, bg.h, bg.r, bg.g, bg.b, bg.a);
if (bg.blend)
    print("\
blend:		%s%s%s\n",
	  bg.blend & sdl.BlendModeBlend ? "Blend " : "",
	  bg.blend & sdl.BlendModeAdd ? "Add " : "",
	  bg.blend & sdl.BlendModeMod ? "Mod " : "");
else
    print("\
blend:		None\n");
#endif
sdl.texture_t fg = sdl.load_texture(ren, "check/1.png");
if (fg == null) {
    print("load_texture error: %s\n", sdl.get_error());
    exit(1);
}
#if DEBUG
print("\n\
texture\n\
format:		%#x\n\
access:		%s\n\
w:		%d\n\
h:		%d\n\
r:		%#x\n\
g:		%#x\n\
b:		%#x\n\
a:		%#x\n",
      fg.format,
      fg.access == sdl.TextureAccessStatic ? "Static" :
      fg.access == sdl.TextureAccessStreaming ? "Streaming" :
      fg.access == sdl.TextureAccessTarget ? "Target" : "???",
      fg.w, fg.h, fg.r, fg.g, fg.b, fg.a);
if (fg.blend)
    print("\
blend:		%s%s%s\n",
	  fg.blend & sdl.BlendModeBlend ? "Blend " : "",
	  fg.blend & sdl.BlendModeAdd ? "Add " : "",
	  fg.blend & sdl.BlendModeMod ? "Mod " : "");
else
    print("\
blend:		None\n");
#endif

#if DEBUG
int32_t points[] = { 50, 10, 60, 20, 70, 30 };
int32_t lines[] = { 150, 10, 160, 30, 170, 20 };
int32_t draw_rects[] = { 180, 10, 10, 10, 190, 20, 10, 10 };
int32_t fill_rects[] = { 200, 10, 10, 10, 210, 20, 10, 10 };
for (i = 0; i < 2; ++i) {
    sdl.render_draw_point(ren, 10, 10);
    sdl.render_draw_points(ren, points);
    sdl.render_draw_line(ren, 20, 20, 40, 40);
    sdl.render_draw_lines(ren, lines);
    sdl.render_draw_rect(ren, 20, 10, 10, 10);
    sdl.render_draw_rects(ren, draw_rects);
    sdl.render_fill_rect(ren, 30, 10, 10, 10);
    sdl.render_fill_rects(ren, fill_rects);
    sdl.render_present(ren);
    sdl.delay(1000);
    ren.r = 0xff;	ren.g = 0;	ren.b = 0;	ren.a = 0xff;
    if (sdl.change_renderer(ren)) {
	print("change_renderer error: %s\n", sdl.get_error());
	exit(1);
    }
}
#endif

/* do not fail below if this does not exist
$ rpm -qf /usr/share/fonts/gnu-free/FreeSans.ttf
gnu-free-sans-fonts-20120503-8.fc20.noarch
 */
sdl.font_t fnt = sdl.open_font("/usr/share/fonts/gnu-free/FreeSans.ttf", 25);
sdl.color_t col = { 0xdd, 0xaa, 0x33 };
sdl.texture_t txt;
float64_t angle = 0;
if (fnt) {
#if DEBUG
    print("\n\
font\n\
style:		");
    if (fnt.style == 0)
	print("Normal");
    else {
	if (fnt.style & sdl.StyleBold)
	    print("Bold ");
	if (fnt.style & sdl.StyleItalic)
	    print("Italic ");
	if (fnt.style & sdl.StyleUnderline)
	    print("Underline ");
	if (fnt.style & sdl.StyleStrikethrough)
	    print("Strikethrough");
    }
    print("\n\
hinting:	");
    switch (fnt.hinting) {
	case sdl.HintingNormal:
	    print("Normal");
	    break;
	case sdl.HintingLight:
	    print("Light");
	    break;
	case sdl.HintingMono:
	    print("Mono");
	    break;
	case sdl.HintingNone:
	    print("None");
	    break;
	default:
	    print("???");
	    break;
    }
    print("\n\
kerning:	%s\n\
outline:	%d\n\
height:		%d\n\
ascent:		%d\n\
descent:	%d\n\
skip:		%d\n\
faces:		%d\n\
style_name:	%#s\n\
family_name:	%#s\n\
fixed:		%s\n",
	  fnt.kerning ? "true" : "false", fnt.outline, fnt.height,
	  fnt.ascent, fnt.descent, fnt.skip, fnt.faces, fnt.style_name,
	  fnt.family_name, fnt.fixed ? "true" : "false");
#endif
    string_t str = "Hello world!";
    sdl.surface_t srf = sdl.render_text_blended(fnt, str, col);
    txt = sdl.create_texture_from_surface(ren, srf);
    if (txt == null) {
	print("create_texture_from_surface error: %s\n", sdl.get_error());
	exit(1);
    }
#if DEBUG
print("\n\
texture\n\
format:		%#x\n\
access:		%s\n\
w:		%d\n\
h:		%d\n\
r:		%#x\n\
g:		%#x\n\
b:		%#x\n\
a:		%#x\n",
      txt.format,
      txt.access == sdl.TextureAccessStatic ? "Static" :
      txt.access == sdl.TextureAccessStreaming ? "Streaming" :
      txt.access == sdl.TextureAccessTarget ? "Target" : "???",
      txt.w, txt.h, txt.r, txt.g, txt.b, txt.a);
if (bg.blend)
    print("\
blend:		%s%s%s\n",
	  txt.blend & sdl.BlendModeBlend ? "Blend " : "",
	  txt.blend & sdl.BlendModeAdd ? "Add " : "",
	  txt.blend & sdl.BlendModeMod ? "Mod " : "");
else
    print("\
blend:		None\n");
#endif
    sdl.free_surface(srf);
    sdl.close_font(fnt);
}

sdl.rect_t rec = { 0, 0, fg.w, fg.h };
if (txt)
    sdl.point_t piv = { txt.w \ 2, txt.h \ 2 };
sdl.rect_t trc;
if (txt)
    trc = { 320 - txt.w \ 2, 240 - txt.h \ 2, txt.w, txt.h };
void paint() {
    sdl.render_clear(ren);
    sdl.rect_t dst = { 0, 0, bg.w, bg.h };
    int32_t x, y;
    for (x = 0; x < 640; x+= 64) {
	dst.x = x;
	for (y = 0; y < 480; y+= 64) {
	    dst.y = y;
	    sdl.render_copy(ren, bg, null, dst);
	}
    }
    if (txt)
	sdl.render_copy_ex(ren, txt, null, trc, angle, piv, sdl.FlipNone);
    sdl.render_copy(ren, fg, null, rec);
    sdl.render_present(ren);
}

sdl.timer_t timer;
int8_t kstate;
#define LEFT			1
#define RIGHT			2
#define UP			4
#define DOWN			8
void kupdate() {
    if (kstate == 0) {
	if (timer) {
	    sdl.remove_timer(timer);
	    timer = null;
	}
    }
    else if (timer == null)
	timer = sdl.add_timer(10, null);
}

int8_t ktimer() {
    int8_t change = false;
    if (kstate & LEFT) {
	if (rec.x > 0) {
	    --rec.x;
	    change = true;
	}
	--angle;
    }
    if (kstate & RIGHT) {
	if (rec.x < 640 - 64) {
	    ++rec.x;
	    change = true;
	}
	++angle;
    }
    if (kstate & UP) {
	if (rec.y > 0) {
	    --rec.y;
	    change = true;
	}
	if (txt)
	    --trc.y;
    }
    if (kstate & DOWN) {
	if (rec.y < 480 - 64) {
	    ++rec.y;
	    change = true;
	}
	if (txt)
	    ++trc.y;
    }
    return change;
}

int8_t done = false, change;
sdl.event_t e = new sdl.event_t;
while (!done) {
    if (!sdl.wait_event(e))
	continue;
    change = false;
    switch (e.type) {
	case sdl.EventQuit:
	    done = true;
	    break;
	case sdl.EventWindow:
	    change = true;
	    break;
	case sdl.EventKeyDown:
	    if (e.repeat == false) {
		switch (e.keysym) {
		    case sdl.Key_Left:
			kstate &= ~RIGHT;
			kstate |= LEFT;
			kupdate();
			change = ktimer();
			break;
		    case sdl.Key_Right:
			kstate &= ~LEFT;
			kstate |= RIGHT;
			kupdate();
			change = ktimer();
			break;
		    case sdl.Key_Up:
			kstate &= ~DOWN;
			kstate |= UP;
			kupdate();
			change = ktimer();
			break;
		    case sdl.Key_Down:
			kstate &= ~UP;
			kstate |= DOWN;
			kupdate();
			change = ktimer();
			break;
		    case sdl.Key_Escape:
			done = true;
			break;
		}
	    }
	    break;
	case sdl.EventKeyUp:
	    switch (e.keysym) {
		case sdl.Key_Left:
		    kstate &= ~LEFT;
		    kupdate();
		    break;
		case sdl.Key_Right:
		    kstate &= ~RIGHT;
		    kupdate();
		    break;
		case sdl.Key_Up:
		    kstate &= ~UP;
		    kupdate();
		    break;
		case sdl.Key_Down:
		    kstate &= ~DOWN;
		    kupdate();
		    break;
	    }
	    break;
	case sdl.EventMouseButtonDown:
	    if (e.button == sdl.ButtonLeft) {
		rec.x = e.x - 32;
		rec.y = e.y - 32;
		change = true;
	    }
	    break;
	case sdl.EventMouseMotion:
	    if (e.state & sdl.ButtonLMask) {
		rec.x = e.x - 32;
		rec.y = e.y - 32;
		change = true;
	    }
	    break;
	case sdl.EventTimer:
	    change = ktimer();
	    break;
    }
    if (change)
	paint();
}

sdl.audio_t au;
au = sdl.open_audio(sdl.MixerDefaultFrequency, sdl.MixerDefaultFormat,
		    sdl.MixerDefaultChannels, 1024);
if (au) {
#if DEBUG
    print("\
audio\n\
au.frequency:		%d (%d)\n\
au.format:		%d (%d)\n\
au.channels:		%d (%d)\n",
	  au.frequency, sdl.MixerDefaultFrequency,
	  au.format, sdl.MixerDefaultFormat,
	  au.channels, sdl.MixerDefaultChannels);
#endif
    //sdl.allocate_channels(0);
    //sdl.volume_music(64);
    /* do not fail below if this does not exist
	$ rpm -qf /usr/share/sounds/KDE-K3B-Finish-Success.ogg
	kde-runtime-4.12.97-1.fc21.x86_64
     */
    sdl.music_t mus = sdl.load_music("/usr/share/sounds/KDE-K3B-Finish-Success.ogg");
    if (mus != null) {
	if (sdl.play_music(mus, 0))
	    print("%s\n", sdl.get_error());
	while (sdl.playing_music())
	    sdl.delay(10);
	sdl.free_music(mus);
    }
    else
	print("%s\n", sdl.get_error());
    sdl.close_audio();
}
if (txt)
    sdl.destroy_texture(txt);
sdl.destroy_texture(fg);
sdl.destroy_texture(bg);
sdl.destroy_renderer(ren);
sdl.destroy_window(win);
sdl.quit();
